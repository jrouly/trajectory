Algorithms
This class covers basic techniques used to analyze problems and algorithms (including asymptotics, upper/lower bounds, best/average/worst case analysis, amortized analysis, complexity), basic techniques used to design algorithms (including divide & conquer / greedy / dynamic programming / heuristics, choosing appropriate data structures), and important classical algorithms (including sorting, string, matrix, and graph algorithms). The goal is for students to be able to apply all of the above to designing solutions for real-world problems.
Algorithms and Data Structures
Classical algorithms and data structures, with an emphasis on implementing them in modern programming environments, and using them to solve real-world problems. Particular emphasis is given to algorithms for sorting, searching, string processing, and graph algorithms. Fundamental algorithms in a number of other areas are covered as well, including geometric algorithms and some algorithms from operations research. The course concentrates on developing implementations, understanding their performance characteristics, and estimating their potential effectiveness in applications.  Analysis of algorithms, with an emphasis on using the scientific method to validate hypotheses about algorithm performance.  Data types, APIs, encapsulation.  Linked data structures, resizing arrays, and implementations of container types such as stacks and queues.  Sorting algorithms, including insertion sort, selection sort, shellsort, mergesort, randomized quicksort, heapsort.  Priority queue data types and implementations, including binary heaps.  Symbol table data types and implementations (searching algorithms), including binary search trees, redblack trees, and hash tables.  Geometric algorithms (searching in point sets and intersection).  Graph algorithms (breadth-first search, depth-first search, MST, shortest paths, topological sort, strong components, maxflow) Tries, string sorting, substring search, regular expression pattern matching.  Data compression (Huffman, LZW).  Reductions, combinatorial search, P vs. NP, and NP-completeness.
Algorithm Design and Analysis
Analysis: asymptotic analysis including lower bounds on sorting, recurrence relations and their solutions.  Graphs: directed, undirected, planar, and bipartite.  Greedy Algorithms: shortest paths, minimum spanning trees, and the union-find data structure (including amortized analysis).  Divide and Conquer Algorithms: integer and matrix multiplication, the fast-fourier transform.  Dynamic Programming: matrix parenthesization, subset sum, RNA secondary structure, DP on trees.  Network Flow: Max-Flow, Min-Cut (equivalence, duality, algorithms).  Randomization: randomized quicksort, median, min-cut, universal hashing, skip lists.  String Algorithms: string matching, suffix trees and suffix arrays.  Complexity Theory: Complexity classes, reductions, and approximation algorithms.
Data Abstractions
The core of this course is fundamental “classical” data structures and algorithms including balanced trees, hashtables, sorting, priority queues, graphs and graph algorithms like shortest paths, etc. The course includes asymptotic complexity (e.g., big-O notation). The course also includes an introduction to concurrency and parallelism grounded in the data structure material. Concurrent access to shared data motivates mutual exclusion.  Independent subcomputations (e.g., recursive calls to mergesort) motivate parallelism and cost models that account for time-to-completion in the presence of parallelism.  More general goals of the course include (1) exposing students to non-obvious algorithms (to make the point that algorithm selection and design is an important and non-trivial part of computer science & engineering) and (2) giving students substantial programming experience in a modern high-level programming language such as Java (to continue developing their software-development maturity).  Course topics: Asymptotic complexity, algorithm analysis, recurrence relations Review of stacks, queues, and binary search trees (covered in CS2) Priority queues and binary heaps Dictionaries and AVL trees, B trees, and hashtables Insertion sort, selection sort, heap sort, merge sort, quicksort, bucket sort, radix sort Lower bound for comparison sorting Graphs, graph representations, graph traversals, topological sort, shortest paths, minimum spanning trees Simple examples of amortized analysis (e.g., resizing arrays) Introduction to multiple explicit threads of execution Parallelism via fork-join computations Basic parallel algorithms: maps, reduces, parallel-prefix computations Parallel-algorithm analysis: Amdahl’s Law, work, span Concurrent use of shared resources, mutual exclusion via locks Data races and higher-level race conditions Deadlock Condition variables
Introduction to Computer Architecture
The goal of the course is to teach the design and operation of a digital computer. It serves students in two ways.  First, for those who want to continue studying computer architecture, embedded systems, and other low-level aspects of computer systems, it lays the foundation of detailed implementation experience needed to make the quantitative tradeoffs in more advanced courses meaningful. Second, for those students interested in other areas of computer science, it solidifies an intuition about why hardware is as it is and how software interacts with hardware.  The subject matter covered in the course includes technology trends and their implications, performance measurement, instruction sets, computer arithmetic, design and control of a datapath, pipelining, memory hierarchies, input and output, and brief introduction to multiprocessors.  The full list of course topics is: Introduction and Performance Technology trends Measuring CPU performance Amdahl’s law and averaging performance metrics Instruction Sets Components of an instruction set Understanding instruction sets from an implementation perspective RISC and CISC and example instruction sets Computer Arithmetic Ripple carry, carry lookahead, and other adder designs ALU and Shifters Floating-point arithmetic and floating-point hardware design Datapath and Control Single-cycle and multi-cycle datapaths Control of datapaths and implementing control finite-state machines Pipelining Basic pipelined datapath and control Data dependences, data hazards, bypassing, code scheduling Branch hazards, delayed branches, branch prediction Memory Hierarchies Caches (direct mapped, fully associative, set associative) Main memories Memory hierarchy performance metrics and their use Virtual memory, address translation, TLBs Input and Output Common I/O device types and characteristics Memory mapped I/O, DMA, program-controlled I/O, polling, interrupts Networks Multiprocessors Introduction to multiprocessors Cache coherence problem
Digital Components and Design
Design of synchronous digital systems using modern tools and methodologies, in particular, digital logic synthesis tools, digital hardware simulation tools, and field programmable gate array architectures.
Computer Architecture and Engineering
Historical Perspectives: RISC vs. CISC, Pipelining, Memory Hierarchy, Virtual Memory, Complex Pipelines and Out-of-Order Execution, Superscaler and VLIW Architecture, Synchronization, Cache Coherency.
eScience
eScience’s basic premise is that in addition to the two accepted scientific inquiry methods: theoretical/mathematical formulation and experimentation, computational simulation/modeling has become the third method for doing science. eScience introduces the application of computational methods to scientific exploration and discovery in the social and natural sciences. Both the class and the laboratory include a broad range of well-defined experiments, verified data inputs, predictable/repeatable outcomes, and open questions to be explored. We begin with an Introduction to eScience, Scientific Method, and Models. Thereafter, we have weekly topics including Spread of Epidemics, Spread of Fire, Movement of Ants and Problem Solving, Predator-prey relationships, Altruism/Collaboration/Competition, Economics, Art and Music, Climate Change, E. coli metabolism of lactose, Cancer and Tumors, Games, Complex Systems and Chaos, Networks, and Fractals. Both theory and practice of computational simulation and modeling techniques are examined as tools to support the scientific method. No computer programming knowledge or calculus is required. By popular student demand, Netlogo 5 is predominantly used as the modeling tool for this course due to its ease of use and extensive library of relevant models. Such tools have the advantage of embodying principles of a systems approach to non-linear, self-organizing, and emergent phenomena that characterize most interesting problems that societies face today. They also offer a bottom-up approach to problem-solution and experimentation in a non-threatening way that does not require the knowledge of programming. At the same time, these tools also provide more adventurous students with the opportunity to modify the natural language-like computer code to test their own ideas about modeling the societal challenge under consideration.  The course includes up to fifteen knowledge units per semester. Each week in the semester is devoted to one knowledge unit. There are two 75-minute lessons per week/knowledge unit. The first lesson of the week uncovers the nature of the societal problem targeted in that particular knowledge unit. The second lesson of the week offers examples of computer-based simulations and models of the problem. Both lessons include many team-based exercises that encourage self-exploration, innovation, and creativity. The lessons are followed by a laboratory session that uses well-defined protocols to guide students through hands-on exploration of computer simulations and models. In the Spring 2013 semester we introduced the use of Audience Response Systems 6 (clickers) for quizzes at the end of each lesson or topic; each quiz consisted of four to five questions about the current topic plus one or two review questions from previous topics. We also experimented with “flipped classroom” methods during some of the clicker quizzes. When responses to questions were diverse and mostly incorrect, we had students discuss their responses amongst themselves and then we re-tested them; as expected, student scores improved on those questions after they had an opportunity to discuss amongst themselves.  Some knowledge units incorporate student projects. Projects are two to three weeks long. They are team-based. Each team includes two to four students. Students are assigned to teams based on their declared major/discipline. Every effort is made to ensure that teams are interdisciplinary.  At the conclusion of this one-semester, 4-hour course, students should be able to: Have an enhanced appreciation for the use of science in addressing real-world problems Apply critical thinking in solving science-related problems Survey literature on current and relevant science-related issues Comfortably communicate scientific concepts with others Perform basic inquiry-based science experimentation using computational models Have fun doing all of the above!
Modeling and Simulation for the Sciences
The modeling process Two system dynamics tool tutorials System dynamics problems with rate proportional to amount: unconstrained growth and decay, constrained growth, drug dosage System dynamics models with interactions: competition, predator-prey models, spread of disease models Computational error Simulation techniques: Euler's method, Runge-Kutta 2 method Additional system dynamics projects throughout, such as modeling falling and skydiving, enzyme kinetics, the carbon cycle, economics and fishing Six computational toolbox tutorials Empirical models Introduction to Monte Carlo simulations Cellular automaton random walk simulations Cellular automaton diffusion simulations: spreading of fire, formation of biofilms High-performance computing: concurrent processing, parallel algorithms Additional cellular automaton simulations throughout such as simulating polymer formation, solidification, foraging, pit vipers, mushroom fairy rings, clouds
Discrete Mathematics
This course will develop advanced mathematics skills appropriate for students pursuing STEM studies such as Engineering, Science, Computer Science, and Mathematics. Topics include sets, numbers, algorithms, logic, computer arithmetic, applied modern algebra, combinations, recursion principles, graph theory, trees, discrete probability, and digraphs.
Mathematical Foundations of Computer Science
Sets Functions and Relations Proof techniques (including direct, contradiction, diagonalization and induction) Graphs Logic (proposition and predicate) Finite Automata (DFAs, NFAs, PDAs) Regular and Context-Free Languages Turing Machines Complexity Classes (P, NP, Exp) NP-Completeness Counting Combinations and Permutations Probability (including conditional probability, independence, and conditional independence) Expectation and Variance Covariance and Correlation Discrete distributions (including Binomial, Negative Binomial, Poisson, and Hypergeometric) Continuous distributions (including Uniform, Normal, Exponential, and Beta) Limit/Concentration results (including Central Limit Theorem, Markov/Chebyshev bounds) Parameter estimation (including maximum likelihood and Bayesian estimation) Classification (including Naive Bayes Classifier and Logistic Regression) Simulation
Discrete Structures I
Introduction to the Peano Axioms and construction of the natural numbers, integer numbers, rational numbers, and real numbers.  Construction and basic properties of monoids, groups, rings, fields, and vector spaces.  Introduction to transfinite ordinals and transfinite cardinals, and Cantor’s diagonalization methods Representation of large finite natural numbers using Knuth’s “arrow notation” Introduction to first order propositional logic, logical equivalence, valid and invalid arguments Introduction to digital circuits Introduction to first order monadic predicate logic, universal and existential quantification, and predicate arguments Elementary number theory, prime factors, Euclid’s algorithm Finite arithmetic, Galois Fields, and RSA encryption Proof techniques, including direct and indirect proofs, proving universal statements, proving existential statements, proof forms, common errors in proofs Sequences, definite and indefinite series, recursive sequences and series Developing and validating closed-form solutions for series Well ordering and mathematical induction Introduction to proving algorithm correctness Second order linear homogeneous recurrence relations with constant coefficients General recursive definitions and structural induction Introduction to classical (Cantor) set theory, Russell’s Paradox, introduction to axiomatic set theory (Zermelo-Fraenkel with Axiom of Choice).  Set-theoretic proofs Boolean algebras Halting Problem
Discrete Structures II
Set-based theory of functions, Boolean functions Injection, surjection, bijection Function composition Function cardinality and computability General set relations Equivalence relations Total and partial orderings Basic counting techniques: multiplication rule, addition rule, Dirichlet’s Box Principle Combinations and permutations Pascal’s Formula and the Binomial Theorem Kolmogorov Axioms and expected value Markov processes Conditional probability and Bayes’ Theorem Classical graph theory: Euler and Hamilton circuits Introduction to spectral graph theory, isomorphisms Trees, weighted graphs, spanning trees Algorithm analysis Formal languages Regular expressions Finite-state automata
Computer Graphics
Shader-based OpenGL programming Coordinate systems and transformations Quaternions and the Arcball interface Camera modeling and projection OpenGL fixed functionality including rasterization Material simulation Basic and advanced use of textures including shadow mapping Image sampling including alpha matting Image resampling including mip-maps Human color perception Geometric representations Physical simulation in animation Ray tracing
Computer Graphics
Computer graphics and its place in computer science Surface modeling Light modeling The Rendering Equation Ray casting Surface scattering (BSDFs) Spatial data structures Photon mapping Refraction Texture Mapping Transformations Rasterization The graphics pipeline GPU architecture Film production and effects Deferred shading Collision detection Shadow maps
Human Aspects of Computer Science
The course is centered on Human-Computer Interaction. The topics covered are: Experimental design and data representation Inferential statistics Writing up experiments User-Centered Design Developing requirements through personas and scenarios Conceptual design, interface design Prototyping: lo-fi and paper Visual Design Evaluation techniques: heuristics, cognitive walkthrough, experiments
Human Computer Interaction
This unit provides a detailed understanding of the underpinning theories, principles and practices of interface design for computer-based systems. It examines issues in the design of system interfaces from a number of perspectives: user, programmer, designer. It explores the application of the relevant theories in practice. The unit will cover topics such as methods and tools for developing effective user interfaces, evaluation methods such as the conduct of usability and heuristic evaluations, design of appropriate interface elements including the design of menus and other interaction styles. The unit also focuses on designing for a diverse range of users and environments.  Topics covered: Background and motivation for HCI Human factors Theoretical foundations: theories, models, principles, standards, guidelines Interface design elements Interface design: methods and principles Interface design: data gathering and task analysis Interaction styles Usability Accessibility Interaction devices Future of HCI
Human Computer Interaction
This module provides an introduction to human-computer interaction. Fundamental aspects of human physiology and psychology are introduced and key features of interaction and common interaction styles delineated. A variety of analysis and design methods are introduced (e.g., GOMS, heuristic evaluation, user-centred and contextual design techniques). Throughout the course, the quality of design and the need for a professional, integrated and usercentered approach to interface development is emphasized. Rapid and low-fidelity prototyping feature as one aspect of this.  Course topics Evaluating interfaces: heuristic evaluation, GOMS Evaluation Data & Empirical Data Lo-fi Prototyping Color, Vision & Perception Some Features of Human Memory Errors Controls, widgets, icons & symbols Elements of visual design Documentation
Human-Computer Interaction
Short-form description: Helping you build human-centered design skills, so that you have the principles and methods to create excellent interfaces with any technology.  Long-form description: In this course, you will learn how to design technologies that bring people joy, rather than frustration. You'll learn several techniques for rapidly prototyping and evaluating multiple interface alternatives -and why rapid prototyping and comparative evaluation are essential to excellent interaction design. You'll learn how to conduct fieldwork with people to help you get design ideas. How to make paper prototypes and low-fidelity mockups that are interactive -- and how to use these designs to get feedback from other stakeholders like your teammates, clients, and users. You'll learn principles of visual design so that you can effectively organize and present information with your interfaces. You'll learn principles of perception and cognition that inform effective interaction design. And you'll learn how to perform and analyze controlled experiments online. In many cases, we'll use Web design as the anchoring domain. A lot of the examples will come from the Web, and we'll talk just a bit about Web technologies in particular. When we do so, it will be to support the main goal of this course, which is helping you build human-centered design skills, so that you have the principles and methods to create excellent interfaces with any technology.
Human Information Processing (HIP)
Senses: Short term sensory memory – receptors – stimuli; Perception; Attention; Memory: Long-term memory – working memory; Mental models; Intention: Decision making and response selection; Action: Response execution (motion or behavior) – responses
Computer Systems Security
This course covers the fundamental concepts and practical applications of computing systems security with a holistic view and an applied approach. Topics include: security concepts and services, physical, operational, and organizational security, the role of people in systems security, introduction to cryptography and public key infrastructure, computing systems hardening, secure code, and secure applications development.  The course emphasis is on developing, deploying, and maintaining a secure computing infrastructure with a handson approach.  List of Topics Topics in this course broadly match topics listed within this CS2013 guidelines and their coverage is detailed in the Body of Knowledge coverage section below. One additional topic is listed in the Additional topics section.
Technology, Ethics, and Global Society
Students that successfully complete the course will be able to: Formulate and defend a position on an ethical question related to technology.  Describe the main ethical challenges currently posed by technology.  Describe the results of group discussion on ethical issues as a consensus position or mutually acceptable differences of opinion.  Analyze a proposed course of action in the context of various cultures, communities, and countries.  Demonstrate effective oral and written communication methods to explain a position on the social responsibilities of software developers and IT workers.  Moral theories and reasoning. Includes applying utilitarianism, deontological ethics, and virtue ethics.  Discussion of relativism and religious ethics. 3 hours.  Professional ethics. Includes definitions of “profession,” codes of ethics, and ACM-IEEE Software Engineering Code of Ethics and Professional Practice. 3 hours.  Privacy. Definitions of privacy, the role of computing in contemporary privacy dilemmas. 6 hours.  Intellectual and intangible property. Definitions of copyright, trademark, and patent, especially as they apply to computer applications and products. Fair use and other limitations to the rights of creators.  Intangible property that is not “creative” in nature. 6 hours.  Trust, safety, and reliability. Causes of computer failure, case studies (including Therac-25). 3 hours.  Review and exams. 3 hours.  Public presentations of independent research projects. 3 hours.  Selection from the following, at instructor discretion (18 hours): Effects of computing on society and personal identity. Social network analysis, Marshall McLuhan, bullying and trolling, crowd-sourced knowledge, cybernetics. 6 hours.  Democracy, freedom of speech, and computing. The First Amendment, protection of children, state censorship, corporate censorship, case studies. 6 hours.  Computing and vulnerable groups. Case studies of effects of computing on prisoners, the elderly, the young, racial and ethnic minorities, religious minorities, people with disabilities, people with chronic diseases, developing countries, and so on. 6 hours.  Autonomous and pervasive technologies. Cases related to data surveillance, moral responsibility for autonomous systems, robots, and systems that function with little human oversight. 6 hours.
Artificial Intelligence Programming
An overview of AI, including search, knowledge representation, probabilistic reasoning and decision making under uncertainty, machine learning, and topics from NLP, information retrieval, knowledge engineering and multi-agent systems.
Artificial Intelligence
INTRODUCTION TO AI. Historical outline of the discipline. Fundamental concepts. Main research areas and application fields.  PROBLEM SOLVING AND SEARCH. State spaces and search methods. Non-informed and informed search strategies. Constraint satisfaction problems. Games and adversarial search.  LOGIC AND REASONING. The use of propositional and first order logic for the representation of knowledge. Knowledge-based reasoning as logical deduction. Inference procedures (forward chaining, backward chaining, resolution).  PLANNING. Plan formation and execution. The STRIPS model. Search in plan spaces.  FOUNDATIONS OF AI. Some critical concepts and philosophical problems of AI.
Introduction to Artificial Intelligence
This course will serve as an introduction to artificial intelligence concepts and techniques.  We will use the Lisp programming language as a computational vehicle for exploring the techniques and their application. Specific topics we will cover include the history and philosophy of AI, Lisp and functional programming, the agent paradigm in AI systems, search, game playing, knowledge representation and reasoning, logical reasoning, uncertain reasoning and Bayes nets, planning, and machine learning. If time permits, we may also briefly touch on multi-agent systems, robotics, perception, and/or natural language processing.
Introduction to Artificial Intelligence
Problem solving with search: uninformed, informed search, search for optimization (hill climbing, simulated annealing, genetic algorithms), adversarial search (minimax, game trees) Logic and Planning: Propositional Logic, syntactic and model-based inference, first order logic (FOL), FOL inference complexity, unification and resolution, planning as FOL inference, STRIPS encoding, state space and plan space planning, partial order planning.  Probability and Machine Learning: Axioms of probability, basic statistics (expectation and variance), inference by enumeration, Bayesian networks, inference through variable elimination and Monte Carlo, intro to supervised machine learning, probabilistic classification with naive Bayes, parameter estimation with maximum likelihood, Perceptrons, parameter estimation with gradient descent, evaluating algorithms with cross validation, confusion matrices and hypothesis testing.  Decision making under uncertainty: Intro to sequential decision making, Markov decision processes, Bellman equation/optimality, value and policy iteration, model-based and model free reinforcement learning, temporal difference methods, Q learning, Function approximation.  I also have one lecture on natural language processing with a very brief introduction to language models, information retrieval and question answering (Watson), but students are not evaluated on this material.
Introduction to Artificial Intelligence
Introduction to Lisp Fundamental Issues What is AI? Foundations of AI, History of AI.  Intelligent Agents Agents and Environments, Structure of Agents.  Problem Solving by Searching Problem Solving Agents, Searching for Solutions, Uninformed Search Strategies: Breadth-First Search, Depth-First Search, Depth-limited Search, Iterative Deepening Depth-first Search, Comparison of Uninformed Search Strategies.  Informed Search and Exploration Informed (Heuristic) Search Strategies: Greedy Best-first Search, A* Search, Heuristic Functions, Local Search Algorithms, Optimization Problems.  Constraint Satisfaction Problems Backtracking Search for CSPs, Local Search for CSPs.  Adversarial Search Games, Minimax Algorithm, Alpha-Beta Pruning.  Reasoning and Knowledge Representation Introduction to Reasoning and Knowledge Representation, Propositional Logic, First Order Logic, Semantic Nets, Other Knowledge Representation Schemes.  Reasoning with Uncertainty & Probabilistic Reasoning Acting Under Uncertainty, Bayes’ Rule, Representing Knowledge in an Uncertain Domain, Bayesian Networks.  Machine Learning Forms of Learning, Decision Trees and the ID3 Algorithm, Nearest Neighbor, Statistical Learning.
Computer Networks I
The course covers various aspects of computer networking, including (1) application layer protocols such as HTTP and SMTP, (2) transport layer (TCP/UDP) and congestion control, (3) routing and IP, and (4) link layer access protocols including Ethernet and 802.11.  Typical schedule: Network architecture, layering, and protocols.  Principles of application-layer, application-layer protocols: FTP, SMTP, DNS.  HTTP, Web Caching and content delivery networks. Peer-to-peer applications.  Socket programming, introduction to transport layer protocols.  Principles of reliable transfer, TCP reliable transfer implementation.  TCP reliable transfer cont’d, RTT and timer, flow control, TCP connection management, state transition. Principles of congestion control.  TCP congestion control. TCP performance: response time. TCP throughput Introduction to network layer. Inside a router.  IPv4 and IP Addressing. IPv6 and ICMP. Routing algorithms.  Internet routing architecture and protocols. Multicast routing.  Introduction to link layer. Multiple access protocols.  Aloha protocol, CSMA. Efficiency of CSMA/CD. Ethernet.  LAN addressing and ARP. ATM networks.  Wireless and mobile networks.
Introduction to Computer Networking
CS144 is an introductory course on computer networking, speciﬁcally the Internet. The course explains how the Internet works, ranging from how bits are modulated on wireless networks to application-level protocols like BitTorrent and HTTP. It also explains the principles of network design, such as layering, packet switching, and the end-to-end argument. Students implement a handful of low-level protocols and services, including reliable transport, IP forwarding, and a Network Address Translation device. Students gain experience reading and understanding RFCs (Internet Protocol speciﬁcations) as statements of what a system should do. The course grounds many of the concepts in current practice and recent developments, such as net neutrality and DNS security.
Computer Networks
This course explores the principles underlying the design of computer networks. We will examine techniques for transmitting information efficiently and reliably over a variety of communication media. We will look at the addressing and routing problems that must be solved to ensure that transmitted data gets to the desired destination. We will come to understand the impact that the distributed nature of all network problems has on their difficulty. We will examine the ways in which these issues are addressed by current networking protocols such as TCP/IP and Ethernet.  Students will meet weekly with the instructor in pairs to present solutions to problem sets and reports evaluating the technical merit of current solutions to various networking problems.
Operating Systems
This course explores the design and implementation of computer operating systems. Topics include historical aspects of operating systems development, systems programming, process scheduling, synchronization of concurrent processes, virtual machines, memory management and virtual memory, I/O and file systems, system security, OS/architecture interaction, and distributed operating systems. The concepts in this course are not limited to any particular operating system or hardware platform. We discuss examples that are drawn from historically significant and modern operating systems including Unix, Windows, Mach, and the various generations of Mac OS.  The objective of this course is threefold: to demystify the interactions between the software written in other courses and hardware, to familiarize students with the issues involved in the design and implementation of modern operating systems, and to explain the more general systems principles that are used in the design of all computer systems.
Parallel Programming Principle and Practice
Part 1: Principle This section covers the very basics of parallel computing, and is intended for someone who is just becoming acquainted with the subject. It begins with a brief overview, including concepts and terminology associated with parallel computing. The topics of parallel memory architectures and programming models are then explored. These topics are followed by a discussion on a number of issues related to designing parallel programs.  Why Parallel Programming?  Parallel Architecture Parallel Programming Models Parallel Programming Methodology Parallel Programming: Performance Part 2: Typical Issues Solved by Parallel Programming This section concludes with several examples of how to parallelize simple serial programs. Including: threads and shared memory programming with TBB and OpenMP, SIMD programming model and Cuda & OpenCL, programming using the Message Passing Paradigm, parallel computing with MapReduce.  Shared Memory Programming and OpenMP: A High Level Introduction Case Studies: Threads programming with TBB Programming Using the Message Passing Paradigm Introduction to GPGPUs and CUDA Programming Model Parallel Computing with MapReduce Part 3: Parallel Programming Case Study and Assignment Students in this course are required to complete several assignments, which account for 30% of their grade.
Introduction to Parallel Programming
Overview of Parallel System Architectures Modeling and Analysis of Parallel Computations Communication Complexity Analysis of Parallel Algorithms Parallel Programming with MPI Parallel Programming with OpenMP Principles of Parallel Algorithm Design Parallel Algorithms for Solving Time Consuming Problems (Matrix calculation, System of linear equations, Sorting, Graph algorithms, Solving PDE, Optimization) Modeling the parallel program executing
Introduction to Compilers
CS 453 teaches students how to implement compilers. Although most computer science professionals do not end up implementing a full compiler, alumni of this course are surprised by how often the skills they learn are used within industry and academic settings. The subject of compilers ties together many concepts in computer science: the theoretical concepts of regular expressions and context free grammars; the systems concept of layers including programming languages, compilers, system calls, assembly language, and architecture; the embedded systems concept of an architecture with restricted resources; and the software engineering concepts of revision control, debugging, testing, and the visitor design pattern. Students write a compiler for a subset of Java called MeggyJava. We compile MeggyJava to the assembly language for the ATmega328p microcontroller in the Meggy Jr RGB devices.  Regular and context free languages including DFAs and NFAs.  Scanning and parsing Finite state machines and push down automata FIRST and FOLLOW sets Top-down predictive parsing LR parse table generation Meggy Jr Simple runtime library AVR assembly code including the stack and heap memory model Abstract syntax trees Visitor design pattern Semantic analysis including type checking Code generation for method calls and objects Data-flow analysis usage in register allocation Iterative compiler design and development Test-driven development and regression testing Revision control and pair programming
Translators and Systems Software
This course covers the design and implementation of translator-oriented systems software, focusing specifically on compilers, with some time spent on related topics such as interpreters and linkers.  Background. Compilers as translators. Other examples of translators: document-processing tools such as ps2pdf and latex2html; web browsers; graph-drawing tools such as dot; source-to-source translators such as f2c; etc.  Lexical analysis. Regular expressions; finite-state automata and their implementation. Scannergenerators: flex.  Parsing. Context-free grammars. Top-down and bottom-up parsing. SLR(1) parsers. Parser-generators: yacc, bison.  Semantic analysis. Attributes, symbol tables, type checking.  Run-time environments. Memory organization. Stack-based environments.  Intermediate representations. Abstract syntax trees, three-address code. Code generation for various language constructs. Survey of machine-independent code optimization.  Interpreters. Dispatch mechanisms: byte-code, direct-threading, indirect-threading. Expression evaluation: Registers vs. operand stack. Just-in-time compilers. Examples: JVM vs. Dalvik for Java; Spidermonkey for JavaScript; JIT compilation in the context of web browsers.  Linking. The linking process, linkers and loaders. Dynamic linking.
Compiler Design
Specific topics covered in this course include: Overview of compilation Lexical analysis Context-free grammars, top-down and bottom-up parsing, error recovery Abstract syntax trees, symbol tables Lexical scoping, types (primitive, record, arrays, references), type checking Object-oriented type systems, subtyping, interfaces, traits Three-address code and other intermediate representations Code generation, data representation, memory management, object layout Code transformation and optimization Class hierarchy analysis Dataflow analysis Register allocation Run-time systems, just-in-time compilation, garbage collection
Compilers
The course covers the design, definition and implementation of programming languages. Students who have been through the class will be able to specify and implement language syntax using regular expressions or context free grammars as appropriate. Students will understand the distinction between no typing, static typing and dynamic typing and be able to implement simple static type systems as well as perform standard syntax analysis for scoping of global, local, and class-visible names. Students will understand the difference between compile time and run time and be able to reason about and make decisions about what should be done at which time. Students will also be introduced to formal semantics as a form of specification of the behavior of a programming language and be able to use formal semantics in the construction of a compiler. Run-time structures such as the stack, activation records and static data such as string constants and dispatch tables are covered. All of the topics up to this point will also be used as part of a large course project to build a simple compiler for a statically typed object oriented language.  Additional topics include register allocation, garbage collection, dataflow analysis, and optimization.
Languages and Compilers
The intended learning objectives of this course are: To describe structures (i.e., “formulas”) using grammars; To parse, i.e., to recognize (build) such structures in (from) a sequence of symbols; To analyze grammars to see whether or not specific properties hold; To compose components such as parsers, analyzers, and code generators; To apply these techniques in the construction of all kinds of programs; To familiarize oneself with the concept of computability.  Topics: Context-free grammars and languages Concrete and abstract syntax Regular grammars, languages, and expressions Pumping lemmas Grammar transformations Parsing, parser design Parser combinators (top-down recursive descent parsing) LL parsing LR parsing Semantics: datatypes, (higher-order) folds and algebras
Topics in Compiler Construction
Scanning, parsing, semantic elaboration, intermediate representation, implementation of the procedure as an abstraction, implementation of expressions, assignments, and control-flow constructs, brief overview of optimization, instruction selection, instruction scheduling, register allocation. (Full syllabus is posted on the website, listed above.)
Principles of Programming Languages
A thorough examination of issues and features in programming language design and implementation, including language-provided data structuring and data-typing, modularity, scoping, inheritance, and concurrency.  Compilation and run-time issues. Introduction to formal semantics. Specific topics include: Overview of compilers and Interpreters (including lexing & parsing) Lambda calculus Functional languages (via Haskell) Formal semantics (mainly operational semantics) Writing interpreters based on formal semantics Static and dynamic type-checking Run-time memory management Data abstraction & modules Object-oriented languages (illustrated via Java and Scala) Shared memory parallelism/concurrency (semaphores, monitors, locks, etc.) Distributed parallelism/concurrency via message-passing (Concurrent ML, Scala Actors)
Introduction to Programming Languages
The course uses definitional interpreters and related techniques to teach the core of several programming languages.  The course begins with a quick tour of writing definitional interpreters by covering substitution, environments, and higher-order functions. The course then dives into several topics in depth: Mutation Recursion and cycles Objects Memory management Control operators Types Contracts Alternate evaluation models
Programming Language Design and Implementation
CSC 2/454 is an introduction to the design and implementation of programming languages. From the design point of view, it covers language features as tools for expressing algorithms. From the implementation point of view, it covers compilers, interpreters, and virtual machines as tools to map those features efficiently onto modern computer hardware. The course touches on a wide variety of languages, both past and present, with an emphasis on modern imperative languages, such as C++ and Java, and, to a lesser extent, on functional languages such as Scheme and Haskell, and dynamic (scripting) languages such as Perl, Python, and Ruby. Rather than dwell on the features of any particular language, it focus on fundamental concepts and on the differences among languages, the reasons for those differences, and the implications those differences have for language implementation.  Specific topics include: formal aspects of syntax and semantics naming, scoping, and binding scanning, parsing, semantic analysis, and code generation control flow, subroutines, exception handling, and concurrency type systems, data abstraction mechanisms, and polymorphism run-time systems, virtual machines, and storage management imperative, functional, logic-based, and object-oriented programming paradigms programming environments and tools
Programming Languages
Successful course participants will: Internalize an accurate understanding of what functional and object-oriented programs mean Develop the skills necessary to learn new programming languages quickly Master specific language concepts such that they can recognize them in strange guises Learn to evaluate the power and elegance of programming languages and their constructs Attain reasonable proficiency in the ML, Racket, and Ruby languages and, as a by-product, become more proficient in languages they already know Course topics: Syntax vs. semantics Basic ML programming: Pairs, lists, datatypes and pattern-matching, recursion Higher-order functions: Lexical scope, function closures, programming idioms Benefits of side-effect free programming Type inference Modules and abstract types Parametric polymorphism Subtyping Dynamically typed functional programming Static vs. dynamic typing Lazy evaluation: thunks, streams, memoization Implementing an interpreter Implementing function closures Dynamically typed object-oriented programming Inheritance and overriding Multiple inheritance vs. interfaces vs. mixins Object-oriented decomposition vs. procedural/functional decomposition a few more minor topics in the same basic space
Principles of Programming Languages
Specific topics covered in this course include: Functional programming concepts in Lisp Syntax, semantics, and evaluation strategies ML programming, including basic types, datatypes, pattern matching, recursion, and higher order functions Types, dynamic/static type checking, type inference, parametric polymorphism Run-time implementations: stacks, heaps, closures, garbage collection Exception handlers Abstract types and modularity Object-oriented programming and systems design Object-oriented language features: objects, dynamic dispatch, inheritance, subtyping, etc.  Multiple inheritance vs. interfaces vs. traits Scala programming, including most basic language features.  Language-based security mechanisms and sandboxing Models of concurrency: shared memory and actors
Programming Languages and Techniques I
Programming Design and Testing Persistent Data Structures & Functional programming Trees & Recursion Mutable Data Structures (queues, arrays) First-class computation (objects, closures) Types, generics, subtyping Abstract types and encapsulation Functional, OO, and Event-driven programming
Principles of Programming Languages
This is a course on the theory of programming languages. Why study these principles? Because they are fundamental to the design, implementation, and application of programming languages.  Programming language design is often regarded as largely, or even entirely, a matter of opinion, with few, if any, organizing principles, and no generally accepted facts. Dozens of languages are in everyday use in research laboratories and in industry, each with its adherents and detractors. The relative merits of languages are debated endlessly, but always, it seems, with an inconclusive outcome. Some would even suggest that all languages are equivalent, the only difference being a matter of personal taste. Yet it is obvious that programming languages do matter!  Yet can we really say that Java is “better” (or “worse”) than C++? Is Scheme “better” than Lisp? Is ML “better” than either of them? Can we hope to give substance to any of these questions? Or should we simply reserve them for late night bull sessions over a glass of beer? While there is certainly an irreducible subjective element in programming language design, there is also a rigorous scientific theory of programming languages that provides a framework for posing, and sometimes answering, such questions. To be sure there are good questions for which current theory offers no solutions, but surprisingly many issues are amenable to a rigorous analysis, providing definite answers to many questions. Programming language theory liberates us from the tar pit of personal opinion, and elevates us to the level of respectable scientific discourse.  Programming language theory is fundamental to the implementation of programming languages, as well as their design. While compiler writers have long drawn on the theory of grammars for parsing and on graph theory for register allocation, the methods used to compile well-known languages such as C do not rely on deep results from programming language theory. For relatively simple languages, relatively simple compilation methods suffice. But as languages become more sophisticated, so must more sophisticated methods be employed to compile them.  For example, some programs can be made substantially more efficient if code generation is deferred until some runtime data is available. A tight inner loop might be ``unrolled'' into a linear instruction sequence once the iteration bound is determined. This is one example of partial evaluation, a technique for program specialization that rests on results from programming language theory. To take another example, modern languages such as ML (and proposed extensions of Java) include what are known as parameterized types to support flexible code re-use. Parameterized types complicate compilers considerably because they must account for situations in which the type of a variable or function argument is not known at compile time. The most effective methods for handling parameterized types rely on typed intermediate languages with quite sophisticated type systems. Here again programming language theory provides the foundation for building such compilers.  Programming language theory has many applications to programming practice. For example, “little languages” arise frequently in software systems -- command languages, scripting languages, configuration files, mark-up languages, and so on. All too often the basic principles of programming languages are neglected in their design, with all too familiar results. After all, the argument goes, these are “just” scripting languages, or “just” mark-up languages, why bother too much about them? One reason is that what starts out as “just” an ad hoc little language often grows into much more than that, to the point that it is, or ought to be, a fully-fledged language in its own right. Programming language theory can serve as a guide to the design and implementation of special purpose, as well as general purpose, languages.  Another application of the theory of programming languages is to provide a rigorous foundation for software engineering. Formal methods for software engineering are grounded in the theory of specification and verification.  A specification is a logical formula describing the intended behavior of a program. There are all kinds of specifications, ranging from simple typing conditions (“the result is a floating point number between 0 and 1”) to complex invariants governing shared variables in a concurrent program. Verification is the process of checking that the implementation indeed satisfies the specification. Much work has gone into the development of tools for specifying and verifying programs. Programming language theory makes precise the connection between the code and its specification, and provides the basis for constructing tools for program analysis.  The theory of programming languages provides a “reality check” on programming methodology, that part of software engineering concerned with the codification of successful approaches to software development. For example, the merits of object-oriented programming for software development are well known and widely touted.  Object-oriented methodology relies heavily on the notions of subtyping and inheritance. In many accounts these two notions are confused, or even conflated into one concept, apparently because both are concerned with the idea of one class being an enrichment of another. But careful analysis reveals that the two concepts are, and must be, distinct: confusing them leads to programs that violate abstraction boundaries or even incur run-time faults.  The purpose of this course is to introduce the basic principles, methods, and results of programming languages to undergraduate students who have completed the introductory sequence in computer science at Carnegie Mellon. I intend for students to develop an appreciation for the benefits (and limitations) of the rigorous analysis of programming concepts.  The development is based on type theory, a general theory of computation that encompasses all aspects of programming languages, from the data with which we compute to the means by which we structure programs.  Programming language “features” are viewed as manifestations of type structure. Basic data structures such as tuples arise as product types, trees and graphs arise as recursive types, and procedures arise as monadic function types. Each language concept is defined by giving its statics, which specify how it interacts with other parts of a program, and its dynamics, which specifies how it is executed on a computer. Type safety is the coherence of the statics with the dynamics; safety is proved as a mathematical theorem governing each language feature. The specific topics vary from one semester to the next, but the course typically covers finite and infinite data structures, higher-order functions, continuations, mutable storage, data abstraction and polymorphism, so-called dynamic typing, parallel computation, laziness, and concurrency, all presented in a single unifying framework.
Functional Programming
The four key skills that students learn are to write parallel functional programs to analyze programs’ sequential and parallel time complexity to write mathematical specifications and verify that programs meet them to structure programs using modules and abstract types One central principle of the course design is that the skills of writing, analyzing, and verifying parallel programs are integrated throughout the semester, rather than separated into units. In the first three weeks of the course, students learn to write basic sequential functional programs on numbers and lists, to analyze their time complexity, and to prove mathematical correctness specifications using induction. Parallelism is introduced in the fourth week: Students learn to write data-parallel functional programs. They learn to analyze not just the usual sequential complexity of programs, but their parallel complexity, and how this influences algorithm and data structure design.  An early example is sorting: One might think that mergesort would have logarithmic parallel complexity, because as a sorting problem is repeatedly divided in half, the length of the longest dependency is logarithmic. However, with lists as the data structure, mergesort has a linear parallel complexity, because just the operation of splitting a list into two halves takes linear time, independently of how many processors are available. This motivates studying mergesort on trees, which has a sublinear parallel complexity. Because the parallelism is deterministic, students can reason about the behavior of their programs as if they were sequential, but run them in parallel. These programming, analysis, and verification skills continue to be interwoven throughout the remainder of the course, as students learn more advanced techniques.  Overall, students learn the following aspects of programming, analyzing, and proving: The organization of programming languages by types Computing by calculation: how programs are evaluated Recursive functions and proofs by induction Asymptotic analysis and recurrence relations Tree parallelism Datatypes, pattern-matching, and structural recursion/induction Parametric polymorphism Higher-order functions Continuation-passing style Exceptions Cost semantics Vector parallelism and map-reduce Modules and abstract types Imperative programming Interaction of parallelism and effects Laziness and streams The course is taught in Standard ML. A variety of examples are used to teach these skills, including sequential and parallel sorting, map-reduce algorithms, regular expression matching, n-body simulation, and game-tree search. The assignments integrate parallel programming, analysis, and verification. For example, in one key assignment, students write and prove correct a regular expression matcher, combining an advanced programming technique called continuation-passing-style with sophisticated inductive reasoning. In another, students implement an algorithm for n-body simulation that has good sequential and parallel complexity, using a mix of tree- and vectorparallelism.
Java Programming I
Object-oriented programming concepts Objects, classes State, behavior Methods, fields, constructors Variables, parameters Scope, lifetime Abstraction, modularization, encapsulation Method overloading Data types Conditional statements, logical expressions Loops Collection processing Using library classes UML class diagrams Documentation Debugging Use of an IDE
Introduction to Computer Science
This course has five distinct modules of roughly three weeks each: (1) We begin with conditionals and recursion, practicing a functional problem-solving approach to a variety of homework problems. Python is the language in which students solve all of their assignments in this module.  (2) In the second module students investigate the fundamental ideas of binary representation, combinational circuits, machine architecture, and assembly language; they complete assignments in each of these topics using Python, Logisim, and a custom-built assembly language named Hmmm. This unit culminates with the handimplementation of a recursive function in assembly, pulling back the curtain on the “magic” that recursion can sometimes seem.  (3) Students return to Python in the third module, building imperative/iterative idioms and skills that build from the previous unit’s assembly language jumps. Creating the Mandelbrot set from scratch, Markov text-generation, and John Conway’s Game of Life are part of this module’s student work.  (4) The fourth module introduces object-oriented skills, again in Python, with students implementing a Date calculator, a Board class that can host a game of Connect Four, and a Player class that implements game-tree search.  (5) The fifth module introduces mathematical and theoretical facets of computer science, including finite-state machines, Turing machines, and uncomputable functions such as Kolmogorov complexity and the halting problem. Small assignments use JFLAP to complement this in-class content, even as students’ work centers on a medium-sized Python final project, such as a genetic algorithm, a game using 3d graphics with the VPython library, or a text-analysis web application.
Software Development Foundations
Major topics covered, in their approximate order of coverage, include the following: Java Basics: Introduction, interpreted versus compiled languages Java Basics: Packages, classpaths, the Java compiler Java Basics: The Eclipse integrated development environment Java Basics: Parameter passing, shallow versus deep copying, value versus reference semantics Java Classes: Fields, methods, accessibility modifiers Java Classes: Constructors, overloading Java Classes: Static fields, methods, initializers Design Patterns: Introduction, historical context Design Patterns: Singleton, Flyweight Java Libraries: java.io.*, java.util.*, java.net.*, java.math.* Java Interfaces: Declaring, implementing, using as types Abstract Data Structures: Stacks, queues, sets Analytical Reasoning: Introduction to interface contracts Analytical Reasoning: Review of basic mathematical types (integers, tuples, strings, sets) Analytical Reasoning: Formal contract specifications Abstract Data Structures: Partial maps (dictionaries), linked-lists Analytical Reasoning: Contract-based Testing and Tracing Design Patterns: Decorator Analytical Reasoning: Assertion-checking wrappers (using Decorator) Java Exceptions: Concepts, declaring, throwing, catching Java Inheritance: Concepts, type system integration, polymorphism Design Patterns: Template Method, Strategy Algorithms as Components: Parameterized sorting implementations Java Generics: Concepts, syntax, subclassing issues Design Patterns: Observer Analytical Reasoning: Introduction to verification Analytical Reasoning: Software verification with objects Java Libraries: javax.swing.*, basic Swing development
Introduction to Program Design
Upon completion of this course, the student should be able to: Understand when to use and write programs over structures, lists, and trees Develop data models for programming problems Write recursive and mutually recursive programs using the Racket programming language Explain when state is needed in value-oriented programming Develop test procedures for simple programs Basic data types (numbers, strings, images, booleans) Basic primitive operations (and, or, +, etc.) Abstracting over expressions to create functions Documenting and commenting functions What makes a good test case and a comprehensive test suite Conditionals Compound data (records or structs) Writing and testing programs over lists (of both primitive data and compound data) Writing and testing programs over binary trees Writing and testing programs over n-ary trees Working with higher-order functions (functions as arguments) Accumulator-style programs Changing contents of data structures Mutating variables
Data Abstraction and Data Structures
This course is being used as an exemplar of how we incorporate communication outcomes into the core curriculum.  As such, the course description looks very much like other courses for data structures and the real difference is in the execution of the course and how the communication skills are integrated into the assignments.  Abstract data types and their implementation as data structures using object-oriented programming. Use of objectoriented principles in the selection and analysis of various ADT implementations. Sequential and linked storage representations: lists, stacks, queues, and tables. Nonlinear data structures: trees and graphs. Recursion, sorting, searching, and algorithm complexity.  Apply appropriate data structures and abstract data types (ADT) such as bags, lists, stacks, queues, trees, tables, and graphs in problem solving.  Apply object-oriented principles of polymorphism, inheritance, and generic programming when implementing ADTs for data structures.  Create alternative representations of ADTs either from implementation or the standard libraries.  Apply recursion as a problem solving technique.  Determine appropriate ADTs and data structures for various sorting and searching algorithms.  Determine time and space requirements of common sorting and searching algorithms.  Communication Assignments: Examples of communication assignments for this course can be found at this site: http://cscomm.lib.muohio.edu/collections/show/3. The assignments incorporate the use of workplace scenarios that provide context for a programming assignment. Students are required to exercise communication skills in the reading and writing of technical documentation in support of the technical products including the creation of test case specifications and API documentation.
Software Engineering Practices
Typical outline of course topics includes: Introduction to Software Engineering Models of Software Process Project Planning and Organization Software Requirements and Specifications Software Design Techniques Software Quality Assurance Software Testing Software Tools and Environments
Software Engineering
Introduction to SaaS and software lifecycles: Waterfall, Spiral, RUP, Agile Project Management: Pair programming and Scrum vs. Planning and Project manager Requirements Elicitation: User Stories vs. Contracts Testing: Behavior Driven Design and Test Driven Development vs. Code then test Maintenance: Legacy, Refactoring, and Agile Version control systems and releases Design patterns Performance, reliability, and security
Software Engineering Practices
Introduction to software engineering practices Requirements and Use Cases Software Reviews, Version Control, and Configuration Management Design: Object domain analysis, associations, behavior Design and Design Patterns Java Review (almost a year since last use) Code reviews and software testing Applications to embedded systems
Software Development
Catalog Description This course presents introductory software engineering concepts including group development, large-scale project work, and theoretical aspects of object-oriented programming. The course expands on material from previous courses. Professional behavior and ethics represent an important component of this course.  Course Description: This course is being used as an exemplar of how we incorporate communication outcomes into the core curriculum.  The catalog description looks very much like other courses for software development; however, the real difference is in the execution of the course and how the communication skills are integrated into the assignments.  CSC 225 (Introduction to Software Development) is an experiential introduction to software development that focuses on learning basic software development principles and communications skills by developing an ongoing project (i.e., the project is carried over and developed during each iteration of the course). Students work as software development teams in the context of a workplace scenario where assignments are reports to a supervisor who uses the information reported for subsequent tasks such as reports for upper management. This strategy focuses students’ learning on selecting critical information for the supervisor to use and presenting it in an accessible and persuasive manner. Student learning occurs through two sets of linked assignments that use formative assessment to achieve competence at the first-semester sophomore level.  Communication Assignments: Examples of communication assignments for this course can be found at this site: http://cs-comm.lib.muohio.edu/collections/show/4.  The following assignments may be found in the Software Engineering Collection.  Program Review Report Customer Requirements Report Prioritized Bug/Enhancement Report Project Management Tools Report Preliminary Test Plan Scrum Process Management
Introduction to Systems and Networking
The course represents a novel integrated approach to presenting side by side both the architecture and the operating system of modern computer systems, so that students learn how the two complement each other in making the computer what it is. The course consists of five modules, corresponding to the five major building blocks of any modern computer system: processor, memory, parallelism, storage, and networking. Both the hardware and system software issues are covered concomitantly in presenting the five units. Topics covered include Processor design including instruction-set design, processor implementation (simple as well as pipelined with the attendant techniques for overcoming different kinds of hazards), processor performance (CPI, IPC, execution time, Amdahl’s law), dealing with program discontinuities (interrupts, traps, exceptions), and design of interrupt handlers Processor scheduling algorithms including FCFS, SJF, priority, round robin, with Linux scheduler as a real world example Memory system including principles of memory management in general (paging in particular) and the necessary hardware support (page tables, TLB), page replacement algorithms, working set concepts, the inter-relationship between memory management and processor scheduling, thrashing, and context switching overheads Memory hierarchy including different organizations of processor caches, the path of memory access from the processor through the different levels of the memory hierarchy, interaction between virtual memory and processor caches, and page coloring Parallel programming (using pthreads), basic synchronization (mutex locks, condition variables) and communication (shared memory), program invariants, OS support for parallel programming, hardware support for parallel programming, rudiments of multiprocessor TLB and cache consistency Basics of I/O (programmed data transfer, DMA), interfacing peripherals to the computer, structure of device driver software Storage subsystem focusing on hard disk (disk scheduling), file systems (naming, attributes, APIs, disk allocation algorithms), example file systems (FAT, ext2, NTFS) Networking subsystem focusing on the transport layer protocols (stop and wait, pipelined, congestion control, windowing) , network layer protocols (Dijkstra, distance vector) and service models (circuit-, message-, and packet-switching), link layer protocols (Ethernet, token ring) Networking gear (NIC, hubs/repeater, bridge, switch, VLAN) Performance of networking (end-to-end latency, throughput, queuing delays, wire delay, time of flight, protocol overhead).
Great Ideas in Computer Architecture
Introduction to C: this includes coverage of the Hardware/Software Interface (e.g., machine and assembly language formats, methods of encoding instructions and data, and the mapping processes from high level languages, particularly C, to assembly and machine language instructions). Computer architectures: how processors interpret/execute instructions, Memory Hierarchy, Hardware Building Blocks, Single CPU Datapath and Control, and Instruction Level Parallelism. The concept of parallelisms, in particular, task level parallelism, illustrated with Map-Reduce processing; Data Level Parallelism, illustrated with the Intel SIMD instruction set; Thread Level Parallelism/multicore programming, illustrated with openMP extensions to the C programming language.
Systems Programming
The major goal of the course is to give students principles, skills, and experience in implementing complex, layered systems. The course includes a quarter-long programming project in which students: (a) build rudimentary data structures in C, such as linked lists, chained hash tables, AVL trees; (b) use them to build an in-memory inverted index and file system crawler; (c) construct a C++-based access methods for writing indexes to disk and accessing disk-based indexes efficiently; and (d) construct a concurrent (threaded or event-driven) web server that exposes a search application.  A substantial portion of the course focuses on giving students in-depth C and C++ skills and experience with practical engineering tools such as debuggers, unit testing frameworks, and profilers. The course stresses the discipline of producing well-structured and readable code, including techniques such as style guidelines and code reviews. Additionally, the course covers topics such as threaded vs. event-driven concurrency, the Linux system call API, memory management, and some security and defensive programming techniques.  The full list of course topics is: C programming pointers, structs, casts; arrays, strings dynamic memory allocation C preprocessors, multifile programs core C libraries error handling without exceptions C++ programming class definitions, constructors and destructors, copy constructors dynamic memory allocation (new / delete), smart pointers, classes with dynamic data inheritance, overloading, overwriting C++ templates and STL Tools and best practices compilers, debuggers, make leak detectors, profilers and optimization, code coverage version control code style guidelines; code review Systems topics: the layers below (OS, compiler, network stack) concurrent programming, including threading and asynchronous I/O file system API sockets API understanding the linker / loader fork / join, address spaces, the UNIX process model
Technology Consulting in the Community
This course has service, personal, and intellectual goals. Its service goal is to build the technical capacity of community organizations by providing effective technology consultants. To promote this effectiveness, and to enrich the intellectual preparation of Carnegie Mellon students, the course teaches students how to: Establish a professional working relationship Quickly assess a complex technical environment and identify problem areas Systematically bring structure to unstructured problems Communicate technical ideas to an often non-technical audience Negotiate with the client acceptable deliverables for the consulting period Develop and execute a work plan Use writing skills to maintain working documents that describe, plan, persuade, and coordinate work with others Reflect and learn from their experience as well as the experience of their colleagues Broaden their understanding of the relevance of information systems and computer science.  Students routinely find the experience to be very personally satisfying. Student consultants learn that they can be effective in helping a community organization make better use of its computers, and help its staff and/or volunteers understand more about the technology. Students also often express that it is refreshing to step outside the grind of Carnegie Mellon life and do something worthwhile in the community.  Specific topics include: Capacity-Building Consulting and Alternative Consulting Models Establishing and Managing Professional Relationships Gathering and Analyzing Information Structuring unstructured problems Researching alternative solutions Analyzing Buy vs. Build Technology Planning Developing and Communicating a Scope of Work and Work Plan Modelling Technical Problem Solving Communicating Difficult Technical Concepts to a Nontechnical Audience Documenting and Analyzing Outcomes Formulating Persuasive Recommendations Synthesizing a Final Consulting Report Orally Presenting Project Outcomes Reflecting on the Consulting Experience More detail on these topics and the course materials are available from the course web site or contact me.
Issues in Computing
In the context of widespread computer usage and society’s ever-growing dependence on computer technology, the course focuses on issues of ethics for the computing professional. A list of topics: Introduction to Computer Ethics Survey of the tools of ethical analysis Practical applications of the tools of ethical analysis Professional ethics Privacy issues Intellectual property protection issues Freedom of expression and the Internet Ethical dimensions of computer system reliability Digital Divide Social impact of technology in the workplace, in education, in healthcare
Ethics & the Information Age
Students learn ethics and moral philosophy as a means for providing a framework for ethically grounded decision making in the information age. Topics include the basic concepts and theories of ethics (moral reasoning and normative frameworks); basic concepts of argumentation and inductive reasoning; an introduction to cyberethics; issues related to networking and network security (threats related to breaches, countering breaches; privacy and personal autonomy (anonymity and accountability, identity theft); intellectual property and ownership rights (Digital Millennium Copyright Act, digital rights management, alternatives to the property model); computing and society, social justice, community, and self-identity digital divide, free speech and censorship; professional ethics and codes of conduct. Four hours are assigned to testing.
Professional Development Seminar
While the course covers Social and Professional Practice topics such as social context, analytical tools, professional ethics, intellectual property, privacy and civil liberties, this exemplar will focus on professional communications.  The course provides opportunities for students to develop their professional communication skills. This exemplar includes examples of four Professional Communication outcomes: Write clear, concise, and accurate technical documents following well-defined standards for format and for including appropriate tables, figures, and references.  Develop and deliver a good quality formal presentation.  Plan interactions (e.g. virtual, face-to-face, shared documents) with others in which they are able to get their point across, and are also able to listen carefully and appreciate the points of others, even when they disagree, and are able to convey to others that they have heard.  Describe the strengths and weaknesses of various forms of communication (e.g. virtual, face-to-face, shared documents)
The Digital Age
The course provides both an introduction to a broad range of computer science topics and discussion of social and ethical issues. Topics vary according to faculty interest and current events.  The technical topics for spring 2013 include: Algorithms & efficiency Data representation Digital logic Computer organization HTML Usability Networks Programming in Python Discussion topics include: Ethics Software reliability Digital data & copyright Software as intellectual property Artificial intelligence Data mining Privacy & security Online education Online voting Energy
General Computer Science
We take an interdisciplinary approach to the traditional CS1 curriculum, where we teach students to program while highlighting the role of computing in other disciplines, then take them through fundamental precepts of the field of computer science. This approach emphasizes for students the essential idea that mathematics, science, engineering, and computing are intertwined in the modern world, while at the same time preparing students to use computers effectively for applications in computer science, physics, biology, chemistry, engineering, and other disciplines.  Instructors teaching students who have successfully completed this course can expect that they have the knowledge and experience necessary to enable them to adapt to new computational environments and to effectively exploit computers in diverse applications. At the same time, students who choose to major in computer science get a broad background that prepares them for detailed studies in the field.  Roughly, the first half of the course is about learning to program in a modern programming model, with applications. The second half of the course is a broad introduction to the field of computer science.  Introduction to programming in Java. Elementary data types, control flow, conditionals and loops, and arrays.  Input and output.  Functions and libraries.  Analysis of algorithms, with an emphasis on using the scientific method to validate hypotheses about algorithm performance.  Machine organization, instruction set architecture, machine language programming.  Data types, APIs, encapsulation.  Linked data structures, resizing arrays, and implementations of container types such as stacks and queues.  Sorting (mergesort) and searching (binary search trees).  Programming languages.  Introduction to theory of computation. Regular expressions and finite automata.  Universality and computability.  Intractability.  Logic design, combinational and sequential circuits.  Processor and memory design.  Introduction to artificial intelligence.
Accelerated Introduction to Computer Science
The course is a compressed introduction into programming along with basic algorithms and data structures. It interleaves these two. The data structures cover lists, trees, queues, heaps, DAGs, and graphs; the algorithms go up through classic ones such as graph shortest paths and minimum spanning trees. The programming is done entirely with pure functions. It begins with graphical animations (such as simple video games), then higher-order functional programming, and encodings of laziness.
Introduction to Programming
This course provides an introduction to problem solving and programming using the Python scripting language.  The specific goals of this course are: To develop problem solving and programming skills to enable the student to design solutions to nontrivial problems and implement those solutions in Python.  To master the fundamental programming constructs of Python, including variables, expressions, functions, control structures, and lists.  To build a foundation for more advanced programming techniques, including object-oriented design and the use of standard data structures (as taught in CSC 222).
Object-Oriented Programming
Building upon basic programming skills in Python from CSC 221, this course focuses on the design and analysis of larger, more complex programs using the industry-leading language, Java. The specific goals of this course are: To know and use basic Java programming constructs for object-oriented problem solving (e.g., classes, polymorphism, inheritance, interfaces) To appreciate the role of algorithms and data structures in problem solving and software design (e.g., objected-oriented design, lists, files, searching and sorting) To be able to design and implement a Java program to model a real-world system, and subsequently analyze its behavior.  To develop programming skills that can serve as a foundation for further study in computer science.
